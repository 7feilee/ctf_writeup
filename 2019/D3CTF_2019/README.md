# D\^3CTF 2019 writeup
>A very fun ctf game hosted by Vidar-Team, L-Team, and CNSS. Thanks to the organizers. Hope to attend full time next year.

## Common

1. step1 recover hint
2. step2 understand `Common Modulus Attacks on Small Private Exponent RSA and Some Fast Variants`
3. step3 construct LLL to recover d1,d2, using e1,d1 to factor N. decrypt the message

```python
N1=22752894188316360092540975721906836497991847739424447868959786578153887300450204451741779348632585992639813683087014583667437383610183725778340014971884694702424840759289252997193997614461702362265455177683286566007629947557111478254578643051667900283702126832059297887141543875571396701604215946728406574474496523342528156416445367009267837915658813685925782997542357007012092288854590169727090121416037455857985211971777796742820802720844285182550822546485833511721384166383556717318973404935286135274368441649494487024480611465888320197131493458343887388661805459986546580104914535886977559349182684565216141697843L
p0=165268930359949857026074503377557908247892339573941373503738312676595180929705525120390798235341002232499096629250002305840384250879180463692771724228098578839654230711801010511101603925719055251331144950208399022480638167824839670035053131870941541955431984347563680229468562579668449565647313503239028017367L

from Crypto.Util.number import getPrime, bytes_to_long,long_to_bytes


pbits = 1024
plow = p0&(2**444-1)
phigh = p0>>(1024-325)
kbits = pbits - 769
print(kbits)

PR.<x> = PolynomialRing(Zmod(N1))
f = phigh*(2**(1024-325))  + (2**444)*x + plow

x0 = f.monic().small_roots(X=2^kbits, beta=0.1)[0]  # find root < 2^kbits with factor >= n^0.3
p1 = int(phigh*(2**(1024-325))  + (2**444)*x0 + plow)
print(N1%p1)
print(long_to_bytes((p1^^p0)>>444))
```
HINT is **3-540-46701-7_14 or 2009/037**
referring [ISBN](https://link.springer.com/chapter/10.1007/3-540-46701-7_14) or https://eprint.iacr.org/2009/037.pdf
 kind of `generalized Boneh and Durfee algorithm`
contruct LLL to solve.

```python
# step 2
from Crypto.Util.number import getPrime, bytes_to_long
import gmpy2
p, q = getPrime(1024), getPrime(1024)
n = p * q
phi = (p-1)*(q-1)
lam = gmpy2.lcm(p-1, q-1)

d1, d2 = getPrime(700), getPrime(700)
e1, e2 = int(gmpy2.invert(d1, lam)), int(gmpy2.invert(d2, lam))
#k1, k2 = (e1*d1)//phi, (e2*d2)//phi
g = phi//lam
s = 1-p-q
k1 = int((e1*d1*g-g)//(s+n))
k2 = int((e2*d2*g-g)//(s+n))

n = 11875320502364454774171549671236103667125647532179492896300465446989377849020555435181833181847404236232102971085735745886811079359206224878619966855007175445387775977034365922319826280515626813743229285943543649929349638982731248800643557525111548906649341392036843279325474585113095570357195329293528029905224730470359179482721618929269368239210237071022647472826819493975164512602716394076112447648046991483222608158550522662725719152029322109628765925522726161447026967485201187119282117247063357513585101516772917884821988309790997310880798365367962320217103305709743218570445897316483984354634708788827719252121
e1 = 869380389098750918356481509564736591726759438891651641346632838635931774119791154998352201188244806537537933824004427999136669434469593402424531890296526045010320811175750873664078106398465343232337541745188262291314278989779132108189481795378342729427490971568595586211978085274985191390014147949631903461437501634412271264072927679735241438776238279128173390965805450240679165513996976973701858618711681540921273359969459278256004613440509940594557979375516622222510835036117252104857254040671752618258296575817966579357532513701043101737093648285615080040339306692729743970727042788083345797977120495596437575911
e2 = 1107279580294254910745280978225272402380105929383806190248664185016541849086006375491272339863374058251117332789789112321967490041243666568697781070864520758048595601783607982184927073714522981975964742363549108678653451181796882598387457314387374308882316782358881702447870913176183756311233132053040680975188942785689944111004892741113060987772468727694518233483959824141496022592582162439280895640347198896365549673145306772742853759864893773237003264793836994114640745003466997211366592213643902231437142185738475489910800859434299522924326048461160164983658621429466435576486281924635294000305416845419027064161
m1 = n^(1/2)
m1 = int(m1)
t = 0.3418
m2= n^(1+t)#<5/14
m2 = int(m2)
bb1,bb2,bb3,bb4 = k1*k2,d1*g*k2,d2*g*k1,d1*d2*g^2
#M = matrix([[n,-m1*n, 0, n**2],
#             [0,m1*e1, -e1*m2, -e1*n],
#             [0,0, e2*m2,  -e2*n],
#             [ 0,0, 0,e1*e2]])

B2 = matrix([[1,-n, 0, n**2],
            [0,e1, -e1, -e1*n],
            [0,0, e2,  -e2*n],
            [ 0,0, 0,e1*e2]])

D2 = matrix([[n,0,0,0],
            [0,m1,0,0],
            [0,0,m2,0],
             [0,0,0,1]])
#print("start")
M = B2*D2# k1k2, k2d1, k1d2, d1d2

for vec in M.LLL()[:1]:
    b1,b2,b3,b4 = vec
    x2 = Matrix([[b1,b2,b3,b4]])*M.inverse()
    a,b,c,d = x2[0]
    print(GCD(b,d))
    print(GCD(c,d))
print("DONE")
d1 = 4340849607275104431418102212872469078215560536801565362304936855413194527699668270143201040001424235250426373056811439363458625499091402002496702998258782629133092222280642701206626507610247646093445840459346891
d2 = 4731548051426826370291879517388633309988301525702722736427523017813246020452598234222679749481649774636466580643829964698595234419959413391697761094916295526219890919625297598414261756229375195290142738285226421

# last step
n = 11875320502364454774171549671236103667125647532179492896300465446989377849020555435181833181847404236232102971085735745886811079359206224878619966855007175445387775977034365922319826280515626813743229285943543649929349638982731248800643557525111548906649341392036843279325474585113095570357195329293528029905224730470359179482721618929269368239210237071022647472826819493975164512602716394076112447648046991483222608158550522662725719152029322109628765925522726161447026967485201187119282117247063357513585101516772917884821988309790997310880798365367962320217103305709743218570445897316483984354634708788827719252121
e1 = 869380389098750918356481509564736591726759438891651641346632838635931774119791154998352201188244806537537933824004427999136669434469593402424531890296526045010320811175750873664078106398465343232337541745188262291314278989779132108189481795378342729427490971568595586211978085274985191390014147949631903461437501634412271264072927679735241438776238279128173390965805450240679165513996976973701858618711681540921273359969459278256004613440509940594557979375516622222510835036117252104857254040671752618258296575817966579357532513701043101737093648285615080040339306692729743970727042788083345797977120495596437575911
e2 = 1107279580294254910745280978225272402380105929383806190248664185016541849086006375491272339863374058251117332789789112321967490041243666568697781070864520758048595601783607982184927073714522981975964742363549108678653451181796882598387457314387374308882316782358881702447870913176183756311233132053040680975188942785689944111004892741113060987772468727694518233483959824141496022592582162439280895640347198896365549673145306772742853759864893773237003264793836994114640745003466997211366592213643902231437142185738475489910800859434299522924326048461160164983658621429466435576486281924635294000305416845419027064161
d1 = 4340849607275104431418102212872469078215560536801565362304936855413194527699668270143201040001424235250426373056811439363458625499091402002496702998258782629133092222280642701206626507610247646093445840459346891
d2 = 4731548051426826370291879517388633309988301525702722736427523017813246020452598234222679749481649774636466580643829964698595234419959413391697761094916295526219890919625297598414261756229375195290142738285226421

import fractions #for gcd function (or easily implementable to avoid import)
import random #for random elements drawing in RecoverPrimeFactors

def failFunction():
    print("Prime factors not found")

def outputPrimes(a, n):
    p = fractions.gcd(a, n)
    q = int(n / p)
    if p > q:
        p, q = q, p
    print("Found factors p and q")
    print("p = {0}".format(str(p)))
    print("q = {0}".format(str(q)))
    return p,q


def RecoverPrimeFactors(n, e, d):
    """The following algorithm recovers the prime factor
        s of a modulus, given the public and private
        exponents.
        Function call: RecoverPrimeFactors(n, e, d)
        Input:     n: modulus
                e: public exponent
                d: private exponent
        Output: (p, q): prime factors of modulus"""

    k = d * e - 1
    if k % 2 == 1:
        failFunction()
        return 0, 0
    else:
        t = 0
        r = k
        while(r % 2 == 0):
            r = int(r // 2)
            t += 1
        for i in range(1, 1001):
            g = random.randint(0, n) # random g in [0, n-1]
            y = power_mod(g, r, n)
            if y == 1 or y == n - 1:
                continue
            else:
                for j in range(1, t): # j \in [1, t-1]
                    x = pow(y, 2, n)
                    if x == 1:
                        p, q = outputPrimes(y - 1, n)
                        return p, q
                    elif x == n - 1:
                        continue
                    y = x
                    x = pow(y, 2, n)
                    if  x == 1:
                        p, q = outputPrimes(y - 1, n)
                        return p, q
p,q = RecoverPrimeFactors(n,e1,d1)

c = 2732448257996535061891294406843656346707270280416818435813858968565361156781227474249634557396589745877825780689347290436995270064258003437553661953962088012073719279893441071296594580006357710624822661721087640994260663192328142718447544766422332315774004977082815567616673821388673597979678461602111577152433202348137747785822854028530740851493779910615206273293672164785403003641496183672181515465759643431856481982556246278078007694973442091398349570217369863760368371995927269049839864868542017129188596475013948253844894358813481434656853206845275766511098746735524361707143410094868325655266205565557902016056

phi = gmpy2.lcm((p-1),(q-1))
d = inverse_mod(65537,phi)

print(long_to_bytes(power_mod(c,d,n)))
```


## Bivariate
> recover high 100 bits and low 100bits of p, we know $p = s_0*2^{924}+p_0+s_1$ and $ N = p * q $ so here we need to find small roots of bivariate polynomials.

```python
##### modified from https://gist.github.com/jhs7jhs/0c26e83bb37866f5c7c6b8918a854333 which is full of bug.#####
class IIter:
    def __init__(self, m, n):
        self.m = m
        self.n = n
        self.arr = [0 for _ in range(n)]
        self.sum = 0
        self.stop = False
    
    def __iter__(self):
        return self

    def __next__(self):
        if self.stop:
            raise StopIteration
        ret = tuple(self.arr)
        self.stop = True
        for i in range(self.n - 1, -1, -1):
            if self.sum == self.m or self.arr[i] == self.m:
                self.sum -= self.arr[i]
                self.arr[i] = 0
                continue
            
            self.arr[i] += 1
            self.sum += 1
            self.stop = False
            break
        return ret
# unknown_ans is for verification
def solve(N, unknown, known, unknown_ans=None, beta=0.4, m=8, t=2):
    assert len(unknown) > 0
    if len(unknown) > 5:
        print("Too many unknown variables!")
        print("This will be much slower")

    n = len(unknown)
    PR = PolynomialRing(Zmod(N), n, var_array=['x'])
    x = PR.objgens()[1]

    # Generate a function for unknown bits
    f = known
    for i in range(n):
        f += x[i] * 2^unknown[i][0]

    # Make function monic
    if 2^unknown[0][0] != 1:
        f = f / 2^unknown[0][0]
    
    f = f.change_ring(ZZ)
    x = f.parent().objgens()[1]

    if unknown_ans is not None:
        v = f(unknown_ans)
        if v != 0:
            g = gcd(N, v)
            print(g,N,v)
            # g must be non-trivial value (p)
            assert g != 1 and g != N

    # d is dimension, sN is sum from the paper
    d = binomial(m + n, m)
    # t = m * tau
    Xbits = beta * t * (d - n + 1)
    Xbits -= d * t
    Xbits += binomial(m + n, m - 1)
    Xbits -= binomial(m - t + n, m - t - 1)
    Xbits *= len(bin(N)[2:]) * (n + 1) / (m * d)

    print("Xbits =", Xbits)
    print("dim =", d)

    Ubits = sum(map(lambda x: x[1], unknown))
    #assert Ubits < Xbits, "Range is too big"

    X = [ 2^v[1] for v in unknown ]

    # Polynomial construction
    g = []
    monomials = []
    Xmul = []

    # g_k,i2,...,in = x2^i2 * x3^i3 * ... * xn^in * f^k * N^max{t-k, 0}
    # for ij in {0,...,m} and sum(ij) <= m - k
    # monomials : x1^k * x2^i2 * x3^i3 * ... * xn^in
    # Xmul : X1^k * X2^i2 * X3^i3 * ... * Xn^in
    for ii in IIter(m, n):
        k = ii[0]
        g_tmp = f^k * N^max(t-k, 0)
        monomial = x[0]^k
        Xmul_tmp = X[0]^k

        for j in range(1, n):
            g_tmp *= x[j]^ii[j]
            monomial *= x[j]^ii[j]
            Xmul_tmp *= X[j]^ii[j]
        
        g.append(g_tmp)
        monomials.append(monomial)
        Xmul.append(Xmul_tmp)

    B = Matrix(ZZ, len(g), len(g))
    for i in range(B.nrows()):
        for j in range(i + 1):
            if j == 0:
                B[i,j] = g[i].constant_coefficient()
            else:
                v = g[i].monomial_coefficient(monomials[j])
                B[i,j] = v * Xmul[j]

    # DO LLL!!!
    B = B.LLL()

    print("LLL finished")

    # Polynomial reconstruction
    h = []
    for i in range(B.nrows()):
        h_tmp = 0
        for j in range(B.ncols()):
            if j == 0:
                h_tmp += B[i, j]
            else:
                assert B[i,j] % Xmul[j] == 0
                v = ZZ(B[i,j] // Xmul[j])
                h_tmp += v * monomials[j]
        h.append(h_tmp)

    if unknown_ans is not None:
        assert h[0](unknown_ans) == 0, "Failed to construct polynomial"
        print(unknown_ans)

    # From https://arxiv.org/pdf/1208.399.pdf
    x_ = [ var('x{}'.format(i)) for i in range(n) ]
    for ii in Combinations(range(len(h)), k=n):
        # It would be nice if there's better way than this :(
        # To use jacobian, we need symbolic variables
        f = symbolic_expression([ h[i](x) for i in ii ]).function(x_)
        jac = jacobian(f, x_)
        v = vector([ t // 2 for t in X ])

        for _ in range(1000):
            kwargs = {'x{}'.format(i): v[i] for i in range(n)}
            tmp = v - jac(**kwargs).inverse() * f(**kwargs)
            # Precision is 150-bit now. If it's not enough, give bigger number
            v = vector((numerical_approx(d, prec=150) for d in tmp))

        v = [ int(_.round()) for _ in v ]
        if h[0](v) == 0:
            print("NICE", v)
            return v
        else:
            print("NO", i, j, v)

from Crypto.Util.number import long_to_bytes,bytes_to_long,getPrime


kbits = 100

p0 = 70183101381888544303008963166686303705281211271104976431225524701819442805298880836204735856239292082507818870576532597246404694606303838784820646882386268908553118409055772805417733336461974049453828322256636431185120377585092386755149831289025664536642018449610239305366634496

c = 18161834136000931804318710762953766213743482564443434780887136604755115896907041808991103992687335065531799563122885969277813250125110476094379065238346947792390555441569305734315404147919964192078095789228893795272059310322973803173663569223940649845150452211556277193150692337923203491154050250116403546939475152982782919531723393337075477258594092917565145606729619682628470693012754133107989365800909915894038148220054898258206790994141623137620618266319444976024190370815481962942443751397349097195607407059537192574581984242818698435751580191933060299998582446913287798531427087343878982989910048553117601080968

ans = solve(N, [(0, kbits),(1024 - kbits, kbits)], p0, unknown_ans=None, m=8, t=2)

ans = [1156669066924061064231551007483, 1235637931221245702519255878409]
p = ans[0]+2**924*ans[1]+p0
print(N%p)
q = N/p
phi = (p-1)*(q-1)
d = inverse_mod(65537,phi)
print(long_to_bytes(pow(c,d,N)))
```
## babyecc

 because $ x^0 = 1$ so
$a = phi(pow(2, 253)) $ and loop $ a = a/2 $ until $pow(x,a,pow(2,253))!=1 $
then factor N, and discrete_log find message mod E.order(), recover message by crt.

```python
sage: A
sage: a = pow(2,251)
sage: A = a+ 84095692866856349150465790161000714096047844577928036285412413565748251721
sage: N = 45260503363096543257148754436078556651964647703211673455989123897551066957489
sage: x,y = (44159955648066599253108832100718688457814511348998606527321393400875787217987,
....:      41184996991123419479625482964987363317909362431622777407043171585119451045333)
sage: B = (y^2-x^3-A*x)%N
sage: B
16675760912734490348153554139884267306276575389279602269504210093434870575877
sage: F1 = IntegerModRing(N)
....: E1 = EllipticCurve(F1, [A, B])
....:
sage: Q = (38540964199002515650791719739792359604837138479627336289206400396582811510323,199965928185
....: 77971795457459214391608424389245274708999563467466438334656636786)
sage: Q = E1(Q)
sage: F11 = IntegerModRing(136974486394291891696342702324169727113)
....: E11 = EllipticCurve(F11, [A, B])
....:
sage: F12 = IntegerModRing(330430173928965171697344693604119928553)
....: E12 = EllipticCurve(F12, [A, B])
....:
....:
sage: P = (44159955648066599253108832100718688457814511348998606527321393400875787217987,
....:      41184996991123419479625482964987363317909362431622777407043171585119451045333)
....: P11 = E11(P)
....:
sage: P = (44159955648066599253108832100718688457814511348998606527321393400875787217987,
....:      41184996991123419479625482964987363317909362431622777407043171585119451045333)
....: P12 = E12(P)
....:
....:
sage: Q11 = E11(Q)
sage: Q12 = E12(Q)
sage: discrete_log(Q11,P11,P11.order(),operation='+')
2747030772933516235490861828783734095
sage: discrete_log(Q12,P12,P12.order(),operation='+')
95492662511786747029049526200082151085
sage: crt([2747030772933516235490861828783734095,95492662511786747029049526200082151085],[P11.order()
....: ,P12.order()])
836417758940725632282634882100678776188798581054802699065832660771295865
sage: long_to_bytes(_)
b'y0u~h@VE~lE4RNeD-NUMber-tHE0Ry'
```

## noise

> solved by [zzh](https://github.com/zzh1996)

```python
from pwn import *

re = remote('129.226.75.200', 20751)

re.recvuntil('get it...\n')

def oracle(num):
    re.sendline('god')
    re.sendline(str(num))
    return int(re.recvline())

lower = None
upper = 2**1024
k = 1
while True:
    r = oracle(k * upper)
    lower = upper - r // k
    upper = upper - (r-2**1000) // k
    # assert lower <= secret <= upper
    print(int(upper-lower).bit_length())
    k *= 2**23
    if k > 2**1024:
        break
re.sendline('bless')
re.sendline(str(lower))
re.interactive()
```
