* [2019年高校网络信息安全管理运维挑战赛crypto题解](#2019年高校网络信息安全管理运维挑战赛crypto题解)
    * [rsa1](##rsa1)
    * [rsa2](##rsa2)
    * [guess](##guess)
    * [AES](##AES)
    * [Signature](##Signature)


# 2019年高校网络信息安全管理运维挑战赛crypto题解


## rsa1

双变量的Coppersmith's求解:
```python
    def coron(pol, X, Y, k=2, debug=False):
        """
        Returns all small roots of pol.
        Applies Coron's reformulation of Coppersmith's algorithm for finding small
        integer roots of bivariate polynomials modulo an integer.
        Args:
            pol: The polynomial to find small integer roots of.
            X: Upper limit on x.
            Y: Upper limit on y.
            k: Determines size of lattice. Increase if the algorithm fails.
            debug: Turn on for debug print stuff.
        Returns:
            A list of successfully found roots [(x0,y0), ...].
        Raises:
            ValueError: If pol is not bivariate
        """
    
        if pol.nvariables() != 2:
            raise ValueError("pol is not bivariate")
    
        P.<x,y> = PolynomialRing(ZZ)
        pol = pol(x,y)
    
        # Handle case where pol(0,0) == 0
        xoffset = 0
    
        while pol(xoffset,0) == 0:
            xoffset += 1
    
        pol = pol(x+xoffset,y)
    
        # Handle case where gcd(pol(0,0),X*Y) != 1
        while gcd(pol(0,0), X) != 1:
            X = next_prime(X, proof=False)
    
        while gcd(pol(0,0), Y) != 1:
            Y = next_prime(Y, proof=False)
    
        pol = P(pol/gcd(pol.coefficients())) # seems to be helpful
        p00 = pol(0,0)
        delta = max(pol.degree(x),pol.degree(y)) # maximum degree of any variable
    
        W = max(abs(i) for i in pol(x*X,y*Y).coefficients())
        u = W + ((1-W) % abs(p00))
        N = u*(X*Y)^k # modulus for polynomials
    
        # Construct polynomials
        p00inv = inverse_mod(p00,N)
        polq = P(sum((i*p00inv % N)*j for i,j in zip(pol.coefficients(),
                                                     pol.monomials())))
        polynomials = []
        for i in range(delta+k+1):
            for j in range(delta+k+1):
                if 0 <= i <= k and 0 <= j <= k:
                    polynomials.append(polq * x^i * y^j * X^(k-i) * Y^(k-j))
                else:
                    polynomials.append(x^i * y^j * N)
    
        # Make list of monomials for matrix indices
        monomials = []
        for i in polynomials:
            for j in i.monomials():
                if j not in monomials:
                    monomials.append(j)
        monomials.sort()
    
        # Construct lattice spanned by polynomials with xX and yY
        L = matrix(ZZ,len(monomials))
        for i in range(len(monomials)):
            for j in range(len(monomials)):
                L[i,j] = polynomials[i](X*x,Y*y).monomial_coefficient(monomials[j])
    
        # makes lattice upper triangular
        # probably not needed, but it makes debug output pretty
        L = matrix(ZZ,sorted(L,reverse=True))
    
        if debug:
            print("Bitlengths of matrix elements (before reduction):")
            print(L.apply_map(lambda x: x.nbits()).str())
    
        L = L.LLL()
    
        if debug:
            print("Bitlengths of matrix elements (after reduction):")
            print(L.apply_map(lambda x: x.nbits()).str())
    
        roots = []
    
        for i in range(L.nrows()):
            if debug:
                print("Trying row %d" % i)
    
            # i'th row converted to polynomial dividing out X and Y
            pol2 = P(sum(map(mul, zip(L[i],monomials)))(x/X,y/Y))
    
            r = pol.resultant(pol2, y)
    
            if r.is_constant(): # not independent
                continue
    
            for x0, _ in r.univariate_polynomial().roots():
                if x0-xoffset in [i[0] for i in roots]:
                    continue
                if debug:
                    print("Potential x0:",x0)
                for y0, _ in pol(x0,y).univariate_polynomial().roots():
                    if debug:
                        print("Potential y0:",y0)
                    if (x0-xoffset,y0) not in roots and pol(x0,y0) == 0:
                        roots.append((x0-xoffset,y0))
        return roots
    n = 21173064304574950843737446409192091844410858354407853391518219828585809575546480463980354529412530785625473800210661276075473243912578032636845746866907991400822100939309254988798139819074875464612813385347487571449985243023886473371811269444618192595245380064162413031254981146354667983890607067651694310528489568882179752700069248266341927980053359911075295668342299406306747805925686573419756406095039162847475158920069325898899318222396609393685237607183668014820188522330005608037386873926432131081161531088656666402464062741934007562757339219055643198715643442608910351994872740343566582808831066736088527333762011263273533065540484105964087424030617602336598479611569611018708530024591023015267812545697478378348866840434551477126856261767535209092047810194387033643274333303926423370062572301
    #ZZ = Zmod(n)
    c = 16396023285324039009558195962852040868243807971027796599580351414803675753933120024077886501736987010658812435904022750269541456641256887079780585729054681025921699044139927086676479128232499416835051090240458236280851063589059069181638802191717911599940897797235038838827322737207584188123709413077535201099325099110746196702421778588988049442604655243604852727791349351291721230577933794627015369213339150586418524473465234375420448340981330049205933291705601563283196409846408465061438001010141891397738066420524119638524908958331406698679544896351376594583883601612086738834989175070317781690217164773657939589691476539613343289431727103692899002758373929815089904574190511978680084831183328681104467553713888762965976896013404518316128288520016934828176674482545660323358594211794461624622116836
    def test():
        P.<x,y> = PolynomialRing(ZZ)
        pol = (10^200*x+y)*(10^200*y+x) - n # Should have a root at (x0,y0)
        XX = next_prime(10^200)
        YY = next_prime(10^200)
        kk = 1
        root = coron(pol, XX, YY, k=2, debug=1)
        for i in root:
            print("aaa")
            e = 65537
            x0_2, y0_2 = 80554375634577518615438386695008921410006481979463250396364716867580983517518170157390631558754951379984609818401525153158058049179857450828511300732679873231618529488409644674348216778296766615218923,26284188956566787061488395375038990922315226573136209037057271138009190100783239284290331572584174262962398525057079432276956326316964537561436371572902729190352463910337199538520792220209028051162087
            p = 10^200*y0_2+x0_2
            q = 10^200*x0_2+y0_2
            phi = (p-1)*(q-1)
            print(n)
            print(p*q ==n)
            d = inverse_mod(e, phi)
            print(long_to_bytes(pow(c,d,n)))
            return
    test()
    print("done!!!")
```

## rsa2
p 256 bit重复多次，构造LLL求解
```python
    e = 65537
    c = 72074917741352632160674674423757226112732503986000125039486711125930276990656443924045288819165868627345704261550380026428346484029915532163917560135274130060403712677039409151760010987858845886090016665156558016254326826349547059132398165597146069935545654906860020446697981554235605548000668071179792369940040506180386344236709376665259555250931229064902253547279742091220081637632484839561818114867753305491466827132794867249268560394596282075249284471959669850300827075751375695495341046098821675671765630616585051408145283934310355450905091174225551852913024234768486683298136180488046648783548871491321003078465957075420450585181898780566907562110082339288183440201802995310694770151937718551875438109333769631500406936973469725930357855181743773516614272920932620803689778201192376634531897671943274986227782204268656867015692338457851232257902297364385868885931304585042560760186518312999852311004441119468693156565576967918680895591024375643850476541598453775623072668482295311781424458452933753379256069914551757794501890946111771992773535292266796984300649540507830481957270227762148818664162360269195888312995110145796745786950401203936544098266440768709581819476569480672433242587899101968249584078375546230742964233750
    n = 120807710153113702551615579080626349972702435654213602643278178850601270671946229285821528380336690426317604059622034599839001416930715968066016772516322170847232613450387418879151680919583407733398280475244970196660246303755390654445483988806163997943960045202300170321033632884706732013873256539789027552900587666422370948750842536533923935656875965991272731558533581897633592458155859972323709278905289729445241014357315813048740496355157322217479024997808766708783034169626351658483634985294355975778256304622956911622334081421352132051371869608818591717661111189285407351900021893457439899221542567630909004930602528901255429064258255953091799356807896508016798627878778491866567622281528441807056062152648122769596905617532839645811871242955534491003544450002957748265702306031022676181061669831693628120952508570252446308607118097142440911574131249381253267168309302968966178203572103064042325655007707720847432033652545364390235670894288288369956445797446648862192044259720010703057599068467348014822871417162946598110099990800849922664801383108437169282005803013729663209291895365964487113632471631243676196750054390014101920098216264290734689252677221687512705895162185620154778448467145374612676883160397044672382343419867
    pattern_size = 256
    prime_size = 2048
    x = 2**pattern_size
    d0 = 2**pattern_size - 1
    w = 2**prime_size
    u, v = divmod(n, w)
    M = matrix([[x, 0, u * d0 % w],
                [0, x, v * d0 % w],
                [0, 0,         w]])
    
    for vec in M.LLL():
      bx, ax = vec[0], -vec[1]
      p = gcd(ax * w + bx, n)
      if 1 < p < n:
        q = n // p
        break
    
    phi = (p-1)*(q-1)
    d = inverse_mod(e, phi)
    print(long_to_bytes(pow(c, d, n)))
```

## guess
关于mersenne-twister-recover恢复,由实现代码`s[i+624] = twist(s[i], s[i+1], s[i+397])`，所以经常说需要624 states 恢复，这题考察往前恢复10 states，则拿到key，AES-ECB解密得到flag.
```python
    def twist(self):
        """ The twist operation. Advances the internal state """
        for i in range(624):
            upper = 0x80000000
            lower = 0x7fffffff
            x = self._int32((self.mt[i] & upper) +
                            (self.mt[(i + 1) % 624] & lower))
            self.mt[i] = self.mt[(i + 397) % 624] ^ (x >> 1)
            if x & 1 != 0:
                self.mt[i] ^= 0x9908b0df
        self.index = 0
 ```
 
```python
    ##### Code borrowed from https://github.com/eboda/mersenne-twister-recover #####
    def twist(a,b,c):
        upper = 0x80000000
        lower = 0x7fffffff
        x = (a & upper) + (b & lower)
        tmp = c ^ (x >> 1)
        if x & 1 != 0:
            tmp ^= 0x9908b0df
        return tmp
    def untwist(c,d):
        tmp = c^d
        if tmp & 0x80000000:
            x = ((tmp ^ 0x9908b0df) << 1) + 1
        else:
            x = tmp << 1
        return x & 0x80000000, x & 0x7fffffff
    def temper(x):
        x ^= x >> 11
        x ^= (x << 7) & 0x9d2c5680
        x ^= (x << 15) & 0xefc60000
        x ^= x >> 18
        return x
    def unshiftRight(x, shift):
        res = x
        for i in range(32):
            res = x ^ res >> shift
        return res
    def unshiftLeft(x, shift, mask):
        res = x
        for i in range(32):
            res = x ^ (res << shift & mask)
        return res
    def untemper(v):
        v = unshiftRight(v, 18)
        v = unshiftLeft(v, 15, 0xefc60000)
        v = unshiftLeft(v, 7, 0x9d2c5680)
        v = unshiftRight(v, 11)
        return v
    ################################################################################
    L = [156960572464426207595318351629939982379, 42913622586402958870984324106172152635, 228929779958303152549080723070652050154, 36124247160566339749815125263290000850, 214201902486792358110805271843352070888, 73930682810320244860159297576365088078, 118416704242981513060300783399549310950, 129491758890545023581610030003327367814, 19950360201715866473105385701539047000, 283553518597909469024019493936907335859, 185035251588975345888359934552482512892, 216361646051389327913088408185682642692, 121443571260194216379266138242395920005, 108259985060817340121693510878785737633, 286783307188230851711761976871483763527, 176530864325540120048190420668156742754, 130811564457043960766412597603008576700, 21695989216012692526332973011455119506, 124648174160905875228226943981991775359, 15020576069166941332162875177987113503, 57753494634188456042993911169740567058, 135957615200764099479815974974191072818, 279930702479664971803504509908046064843, 68512318756605680964121445853962789352, 186161420350521806275470243794627347046, 285991739281678233672168569868573843807, 152434287153901773356626230864411970530, 302101964785822485731874677205607133374, 325472724656613695427337297633410204037, 335630302533689332773128010524893879848, 275461518361959344854257464272748871746, 231078141372316738470009350547204851855, 336930970621400026360623694896007336610, 267458524113519889457663751212102965966, 65367864030685001049715383482279206384, 170505986227917354158277664102080808965, 259223700054648661927303057070159653096, 8283211952895064809429079220954714679, 335345700804031119060480751275564565734, 288709246540530336430465495120650576202, 194688311498032443505615593854117241025, 119586241314296553530985429085818333144, 306522740512978203873231490272095386893, 325484851399774255411092655521472399057, 282416697023150020787104333322784939031, 244057478564040763216973892158029118455, 86037980575729594940836953456096790377, 296774238972787429003060616067570737774, 57643461126730124556794284472423093512, 244128935991743289852579681368572777163, 28553202208435251386070942564369133869, 337243700705635920237466770132769739962, 28880674817950846715489242352004861377, 226837315945598809102024349664298890211, 280228151712253144349895705420564921223, 276402507329982372570992821196098795668, 157313965071695330041212719135252624457, 333625913312015319559629269279735315678, 267856782069138529074235103799475406314, 149387051611758084101296609255381347934, 197691875361124929974285772417696876643, 186735614748580974743953086046644179967, 59241165541117260770732017742862677177, 37191100187998300596929083085791118048, 128643567839793156423739347731346465634, 80209942352134962882720467234446012422, 15458755117271499412029899357270320871, 99262517398366695545562960085319750853, 332065768396180299323069928784029124436, 237950919773536469529188742654830666878, 102539390693292482892365450074246279237, 194456656890918515929375803878313727142, 6659905499874585277705777605300778143, 207436785784934764746386175223334011927, 92539807769506553056857816437821940210, 304124209468077709833589619438842848531, 185139340907009509822219543542752760355, 71574259839120931962368850195549913061, 242873544638447100894649514690104464766, 236980579452354516399007966180392506314, 228044003207499066982722209942510394755, 288861541336607806231593391745859085501, 93721141556339073623449942015112747800, 322265956043403719182876665706163574364, 274725580682814147207442277750068811097, 243653971864233179921116770729270092987, 150366949773094630930862318477567400991, 78709553820088561904922586054379142304, 197013048915557870257004342467655618185, 185202952208555269012265197547436855256, 152942526299425120033160045664365747979, 136730654494454035238278380353142101176, 92280202728281106319617558085037670995, 159250528771086991769803230203088185383, 123160056972859064011096483020294306313, 296959493449910244146973990742246914685, 292167202587208436016138047672010008046, 298428607796891252079068316633690408443, 250023529475976107720199260808574562818, 273717822113757204596436105843453322184, 76973205833412855062807312105897115437, 268024719320380521888932740313602140468, 56825023470711231735069965719316845123, 120745758561745740064471061336421848309, 166647082921230031233443597866487873689, 262817122148782818320190438907710758782, 281006472498890644174343366257148755819, 30045387176162036337402767569249435129, 251590957127978856904070821144278614964, 473247906682438195115804125463873233, 227688867221362670947340794882965188115, 66210165394360321727569194809275614341, 88902692730365123620813328849356743040, 214352362807789341157646520357528027264, 26952575954984597800999503388786502258, 99435355152969279261802536223512911099, 199088610921126987147017499952179379367, 220465721936188127376332587943705031118, 61427233028142795398611326527824030060, 16833231127302353398388349917340949733, 128097865725513168384272800026577701120, 202011692428047753606410045132821598392, 158964025212124059053185795440910032856, 150935111226337571698748079221154125010, 204634005083242803005317140860066593747, 78640877649138534815191302162698614526, 136928603690759946783595674676937494432, 326918761130312856674823719626755121204, 289126951415321120344748782452316091505, 328245581572655275769361602332368275441, 233601639423370428335188840916402440078, 274274982557638915024208280479901159493, 248644231733341385451856602138986680506, 249291016290036658000258248531895996161, 123659905867345140595862924347434963633, 117506617369328991086604067069962985054, 138474308454716917360500464852443815811, 234771763890789846920961698618030552569, 276237995330982441934445057842919651089, 136578977137782347172142233910859502052, 314512488585442566312705940424908578714, 316618152725643446517718748731042057974, 41381402661396567363709296116498325167, 214169964875935823036302266135374062307, 211596654223424255071422393669140204599, 194027167486054011167747262976303591850, 175306250487192719973097722121170907718, 179003792442803196857501381117580490921, 163421004410949088938279912730675345030, 224133201984307747349350345252001216524, 169824554458462128341384058233130180284, 39454123893934774211447937877568370769, 61636914617401313777616685331285108139, 307137177997820375390249391476860839030, 5037896144222966507190205565681746274, 23887567300670501351207867934752393857, 233077199468111650146724562614238367658, 269459029802369986422549710180113859704, 185291918934463394302958734871727293897, 88179122667486018707553262924249221248]
    #%%
    state = []
    for l in L:
        state += [l % 2**32, (l >> 32) % 2**32, (l >> 64) % 2**32, (l >> 96) % 2**32, ]
    state = map(untemper, state)
    state = [0]*11 + state
    for i in range(11):
        a,b = untwist(state[i+397], state[i+624])
        state[i] = (state[i] & 0x7fffffff) | a
        if i == 10:
            print state[i+1] & 0x7fffffff
            print b
        else:
            state[i+1] = (state[i+1] & 0x80000000) | b
    import random
    random.setstate((3, tuple((state[1:1+624] + [0L])), None))
    tmp = ""
    for i in range(4):
        tmp += str(random.random())
    import hashlib
    from Crypto.Cipher import AES
    key = hashlib.md5(tmp).digest()
    aes = AES.new(key,AES.MODE_ECB)
    enc = '129aabdcea36cdd7670ff7b2f4991679b1ff0b17716957d4d164c4489483d7899ec8232aba21ad57da661da35fa8e3c60b60c2a0b216b6f1d85069efd7a04864d14348e7eae281280658d8964f57f693'
    print aes.decrypt(enc.decode('hex'))
```
## AES

题目是AES-CTR, 相当于OTP, 爆破CTR initial_value from 1426 to 3682

```python
    from pwn import *
    import binascii
    import os
    from Crypto.Cipher import AES
    from Crypto.Util import Counter
    msg = b"flag{"+ b" "*22 + b"}"
    '''
    # str to bytes  
    sb = bytes(s, encoding = "utf8")  
    # bytes to str  
    bs = str(b, encoding = "utf8")
    '''
    def strb_str(target):
        length = len(target)
        result = bytearray()
        i = 2
        while 1:
            if target[i] == "\\" and target[i+1] == "x":
                result.extend([int(target[i+2:i+4],16)])
                i +=4
            elif target[i] == "\\" and target[i+1] == "t":
                result.extend([ord('\t')])
                i +=2
            elif target[i] == "\\" and target[i+1] == "n":
                result.extend([ord('\n')])
                i+=2
            elif target[i] == "\\" and target[i+1] == "\\":
                result.extend([ord('\\')])
                i+=2
            elif target[i] == "\\" and target[i+1] == "r":
                result.extend([ord('\r')])
                i +=2
            elif target[i] == "\\" and target[i+1] == "'":
                result.extend([ord('\'')])
                i +=2
            else:
                result.extend([ord(target[i])])
                i +=1
            if i >= length - 1:
                break
        return bytes(result)
    def ttt(target):
        length = len(target)
        result = bytearray()
        i = 0
        while 1:
            result.extend([ord(target[i])])
            i+=1
            if i >= length:
                break
        return bytes(result)
    for i in range(1426,3682,29):
        print(i)
        io = remote("111.186.57.123",10001)
        io.recvuntil(b"flag: ")
        data = bytes.decode(io.recvuntil(b"\nPlease input your plaintext: "))
        rec = data.split("\nPlease")[0]
        enc = strb_str(rec)
        if len(enc) !=30:
            print(rec)
        for k  in range(0,29):
            msg = b"\x00"*15
            tmp = i+k
            for j in range(0,15):
                if tmp >= 255:
                    msg+= (255).to_bytes(1, byteorder='big')
                    tmp = tmp - 255
                else:
                    msg+= (tmp).to_bytes(1, byteorder='big')
                    tmp = 0
            tosend = binascii.hexlify(msg)
            io.sendline(tosend)
            io.recvuntil(b"Here is your ciphertext: ")
            chunk = bytes.decode(io.recvuntil(b"\nPlease input your plaintext: "))
            chunk = chunk.split("\nPlease")[0]
            to = strb_str(chunk)
 [writeup-xy86-1-](media/15742502742899/writeup-xy86-1-.md)           if len(to) !=30:
                print(chunk)
            flag = xor(xor(to,msg),enc)
            if b"flag" in flag:
                print(flag)
                exit(1)
        io.close()
    
    '''
    msg = b"flag{"+ b"~"*24 + b"}"
    def enc(msg, key):
        ctr = Counter.new(128,  initial_value=sum(msg))
        print(ctr)
        cipher = AES.new(key, AES.MODE_CTR, ctr)
        print(cipher)
        return cipher.encrypt(msg)
    enc(msg,key)
    # initial_value from 1426 to 3682
    '''
```

## Signature

copy from [上交校赛](https://github.com/ligongzzz/SJTU-CTF-2019-writeup/blob/b2d0c40ef7be0ebfd0dd380604fb02a91f5e1618/Crypto/CRC%20Forgery.md)
这道题将明文分成了两段，我们需要从前和从后分别推到中间空缺的16个明文是什么。
对于前一段，由于密钥已知，我们直接使用加密方法，将前一段后面16个字符补0进行加密。对于后一段，使用倒推的方法，由于密钥的最后一位为1，所以根据现存的明文和密文可以判断出这一位的前64位是0还是1，所以可以由此循环倒推得到开头的16个字符。
最后将第一段的最后16个字符和后一段的开头16个字符异或一下，就是中间空缺的部分了。

```python
    import binascii
    import os
    import random
    
    def b2n(b):
        res = 0
        for i in b:
            res *= 2
            res += i
        return res
    
    def n2b(n, length):
        tmp = bin(n)[2:]
        tmp = '0'*(length-len(tmp)) + tmp
        return [int(i) for i in tmp]
    
    def s2n(s):
        return int(binascii.hexlify(s), 16)
    
    def crc64(msg):
        msg = n2b(s2n(msg), len(msg)*8)
        msg += const
        print(msg)
        for shift in range(len(msg)-64):
            if msg[shift]:
                for i in range(65):
                    msg[shift+i] ^= poly[i]
        res = msg[-64:]
        return b2n(res)
    
    const = n2b(0xdeadbeeffeedcafe, 64)
    poly  = n2b(0x10000000247f43cb7, 65)
    
    ans_raw2 = n2b(0x1337733173311337,64)
    
    src_raw1 = bytearray.fromhex(input())
    src_raw2 = bytearray.fromhex(input())
    src_raw1 = n2b(s2n(src_raw1),len(src_raw1)*8)
    src_raw2 = n2b(s2n(src_raw2),len(src_raw2)*8)
    src_raw1+=[0 for _ in range(64)]
    src_raw2+=const
    
    for shift in range(len(src_raw1)-64):
        if src_raw1[shift]:
            for i in range(65):
                src_raw1[shift+i] ^= poly[i]
    
    for shift in range(len(src_raw2)):
        ans_raw2.insert(0,0)
        if src_raw2[-shift-1]!=ans_raw2[-shift-1]:
            for i in range(65):
                ans_raw2[i] ^= poly[i]
    
    ans1 = src_raw1[-64:]
    ans2 = ans_raw2[:64]
    
    print(hex(b2n(ans1)^b2n(ans2)))
```
